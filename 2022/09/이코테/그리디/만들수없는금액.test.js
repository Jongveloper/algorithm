/**
 * 미지의 것
 * - N개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟값
 * 자료
 * - N개의 동전 중 가장 큰 동전을 기준으로 반복문을 기준으로 돌면
 *   작은 수 중 어떤 것이 없는 지 찾을 수 있다.
 * 조건
 * - 화폐단위는 1,000,000이하의 자연수이다.
 * 계획
 * - N개의 동전 중 최댓값을 할당한 변수를 선언한다.
 * - 주어진 배열만큼 이중반복문을 돌며 누적값을 만들고 만들 수 있는 동전 수(누적값)를 coin배열에 넣는다.
 * - i=1 부터 최댓값만큼 반복문을 돌며 coin배열에 i가 있는 지 확인한다.
 * - i가 전부 있으면 coin배열에 최댓 값 + 1을 리턴한다.
 * - i가 없는 것이 있으면 i를 리턴한다.
 * 반성
 * 문제를 풀 때 항상 문제에서 요구하는 요구사항이 어떤 것인지 확인을 잘 해야할 것 같습니다.
 * 처음 누적 값을 설정하지 않았을 때, 원하지 않는 결괏값이 나왔고
 * 조금 헤매다가 누적값이 떠올라 누적값으로 대체했습니다.
 * 처음 계획을 세울 때, 누적 값을 캐치했다면 더욱 빨리 풀 수 있었을텐데
 * 이 부분이 아쉬웠습니다.
 */

const solution = (arr) => {
  const max = Math.max(...arr);

  const coins = [];

  for (let i = 0; i < arr.length; i += 1) {
    coins.push(arr[i]);
    let acc = arr[i];
    for (let j = i + 1; j < arr.length; j += 1) {
      acc += arr[j];
      coins.push(acc);
    }
    acc = 0;
  }

  for (let i = 1; i <= max; i += 1) {
    if (coins.indexOf(i) === -1) {
      return i;
    }
  }
  return Math.max(...coins) + 1;
};

describe('만들 수 없는 금액', () => {
  it('N개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟 값을 리턴합니다.', () => {
    expect(solution([3, 2, 1, 1, 9])).toBe(8);
    expect(solution([3, 5, 7])).toBe(1);
  });
});
