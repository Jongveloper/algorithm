/**
 * 미지의 것
 * 지도
 *
 * 자료
 * - 벽 : 1
 * - 길 : 0
 * arr에 있는 값을 toString(2)로 2진법으로 변환할 수 있다.
 * 2진법으로 변경한 후 글자수가 5글자 미만이라면 앞에 0을 추가하면
 * 벽과 길을 구별할 수 있다.
 *
 * 조건
 * 지도 1과 지도 2 중 하나라도 벽이 있다면 벽이다.
 * 지도 1과 지도 2 둘 다 공백이라면 길이다.
 *
 * 계획
 * arr1과 arr2를 모두 2진법으로 변환한다.
 * arr1과 arr2의 요소를 탐색하며 글자수가 5글자 미만이라면 앞에 0을 추가한다.
 * 2진법으로 변환된 배열을 탐색하며 둘 중 하나라도 1이라면 '#'을 둘 다 0이라면 ' '을 더한 후, 배열에 넣는다.
 *
 * 반성
 * 간단한 문제인데 은근히 오래걸린 문제였습니다.
 * 이중 반복문을 사용할 때 인덱스 번호를 추리는 부분을
 * 유의해서 풀어야겠습니다!
 */

const solution = (n, arr1, arr2) => {
  const answer = [];
  for (let i = 0; i < n; i += 1) {
    const zeroFillArr1 = arr1[i].toString(2).padStart(n, 0);
    const zeroFillArr2 = arr2[i].toString(2).padStart(n, 0);

    let rows = '';
    for (let j = 0; j < n; j += 1) {
      if (zeroFillArr1[j] === '1' || zeroFillArr2[j] === '1') {
        rows += '#';
      } else {
        rows += ' ';
      }
    }
    answer.push(rows);
  }

  return answer;
};

describe('비밀지도', () => {
  it('완성된 지도가 출력됩니다.', () => {
    // expect(solution(5, [9, 20, 28, 18, 11], [30, 1, 21, 17, 28])).toEqual([
    //   '#####',
    //   '# # #',
    //   '### #',
    //   '#  ##',
    //   '#####',
    // ]);
  });

  expect(
    solution(6, [46, 33, 33, 22, 31, 50], [27, 56, 19, 14, 14, 10]),
  ).toEqual(['######', '###  #', '##  ##', ' #### ', ' #####', '### # ']);
});
