/**
 * 미지의 것
 * - 누적 곱을 통해 최솟값을 만든 값
 * 자료
 * - a배열을 오름차순 정렬
 * - b배열을 내림차순 정렬
 * 위 과정을 하면 최솟값과 최댓값을 곱해 누적 곱에서 나올 수 있는 최솟값을 만들 수 있다.
 *
 * 조건
 * 배열의 크기 : 1,000이하의 자연수
 * 배열 원소의 크기 : 1,000이하의 자연수
 * 계획
 * - a배열을 오름차순 정렬한다.
 * - b배열을 내림차순 정렬한다.
 * - 누적곱을 구해 리턴한다.
 *
 * 반성
 * reduce를 쓸 수 있음에도 처음부터 reduce를 사용하지 않고
 * 반복문을 통해 풀었습니다.
 * 고차함수를 사용하기에 적절한 문제는
 * 처음부터 고차함수를 사용해야겠습니다.
 */

const solution = (a, b) => {
  a.sort((c, d) => c - d);
  b.sort((e, f) => f - e);

  return a.reduce((total, value, i) => total + value * b[i], 0);
};

describe('최솟값 만들기', () => {
  it('누적곱을 통해 나올 수 있는 최솟값을 만들어 리턴합니다.', () => {
    expect(solution([1, 4, 2], [5, 4, 4])).toBe(29);
  });
});
